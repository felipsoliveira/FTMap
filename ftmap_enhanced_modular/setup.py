#!/usr/bin/env python3
"""
FTMap Enhanced - Setup e Instala√ß√£o
Script para configurar ambiente e depend√™ncias
"""

import os
import sys
import subprocess
import platform
from pathlib import Path
import requests
import json


def print_header():
    """Imprime cabe√ßalho do setup"""
    print("üõ†Ô∏è  FTMap Enhanced - Setup e Instala√ß√£o")
    print("="*50)
    print(f"üñ•Ô∏è  Sistema: {platform.system()} {platform.release()}")
    print(f"üêç Python: {sys.version}")
    print()


def check_python_version():
    """Verifica vers√£o do Python"""
    min_version = (3, 8)
    current_version = sys.version_info[:2]
    
    print("üîç Verificando vers√£o do Python...")
    
    if current_version >= min_version:
        print(f"‚úÖ Python {sys.version.split()[0]} OK")
        return True
    else:
        print(f"‚ùå Python {min_version[0]}.{min_version[1]}+ necess√°rio")
        print(f"   Vers√£o atual: {current_version[0]}.{current_version[1]}")
        return False


def install_pip_dependencies():
    """Instala depend√™ncias Python"""
    print("\nüì¶ Instalando depend√™ncias Python...")
    
    dependencies = [
        "numpy>=1.21.0",
        "scipy>=1.7.0", 
        "pandas>=1.3.0",
        "scikit-learn>=1.0.0",
        "matplotlib>=3.4.0",
        "seaborn>=0.11.0",
        "plotly>=5.0.0",
        "biopython>=1.79",
        "rdkit-pypi>=2022.3.0",
        "openmm>=7.6.0",
        "mdanalysis>=2.0.0",
        "pymol-open-source>=2.5.0",
        "joblib>=1.1.0",
        "tqdm>=4.62.0",
        "requests>=2.26.0",
        "jinja2>=3.0.0"
    ]
    
    failed_packages = []
    
    for package in dependencies:
        try:
            print(f"  üì• Instalando {package}...")
            result = subprocess.run([
                sys.executable, "-m", "pip", "install", package
            ], capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                print(f"     ‚úÖ {package} instalado")
            else:
                print(f"     ‚ùå Erro ao instalar {package}")
                failed_packages.append(package)
                
        except subprocess.TimeoutExpired:
            print(f"     ‚è∞ Timeout ao instalar {package}")
            failed_packages.append(package)
        except Exception as e:
            print(f"     ‚ùå Erro inesperado: {str(e)}")
            failed_packages.append(package)
    
    if failed_packages:
        print(f"\n‚ö†Ô∏è  Pacotes com falha na instala√ß√£o:")
        for package in failed_packages:
            print(f"   - {package}")
        print("\nüí° Tente instalar manualmente:")
        print(f"   pip install {' '.join(failed_packages)}")
        return False
    else:
        print("\n‚úÖ Todas as depend√™ncias Python instaladas!")
        return True


def check_external_tools():
    """Verifica ferramentas externas necess√°rias"""
    print("\nüîß Verificando ferramentas externas...")
    
    tools = {
        "AutoDock Vina": {
            "command": "vina",
            "install_hint": "Baixe de: http://vina.scripps.edu/",
            "required": True
        },
        "Open Babel": {
            "command": "obabel",
            "install_hint": "conda install -c conda-forge openbabel",
            "required": True
        },
        "PyMOL": {
            "command": "pymol",
            "install_hint": "conda install -c conda-forge pymol-open-source",
            "required": False
        },
        "GROMACS": {
            "command": "gmx",
            "install_hint": "conda install -c conda-forge gromacs",
            "required": False
        }
    }
    
    missing_required = []
    missing_optional = []
    
    for tool_name, info in tools.items():
        try:
            result = subprocess.run([info["command"], "--help"], 
                                  capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                print(f"  ‚úÖ {tool_name} encontrado")
            else:
                raise subprocess.CalledProcessError(1, info["command"])
                
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
            print(f"  ‚ùå {tool_name} n√£o encontrado")
            print(f"     üí° {info['install_hint']}")
            
            if info["required"]:
                missing_required.append(tool_name)
            else:
                missing_optional.append(tool_name)
    
    if missing_required:
        print(f"\n‚ö†Ô∏è  Ferramentas obrigat√≥rias ausentes: {', '.join(missing_required)}")
        return False
    
    if missing_optional:
        print(f"\nüí° Ferramentas opcionais ausentes: {', '.join(missing_optional)}")
        print("   Sistema funcionar√° com funcionalidade reduzida")
    
    return True


def setup_directories():
    """Configura estrutura de diret√≥rios"""
    print("\nüìÅ Configurando estrutura de diret√≥rios...")
    
    base_dir = Path(__file__).parent.parent
    
    directories = [
        "data/input",
        "data/output", 
        "data/temp",
        "data/examples",
        "logs",
        "tests/unit",
        "tests/integration",
        "docs/api",
        "docs/tutorials"
    ]
    
    for dir_path in directories:
        full_path = base_dir / dir_path
        full_path.mkdir(parents=True, exist_ok=True)
        print(f"  üìÇ {dir_path}")
    
    print("‚úÖ Estrutura de diret√≥rios criada")


def download_example_files():
    """Baixa arquivos de exemplo"""
    print("\nüì• Baixando arquivos de exemplo...")
    
    examples_dir = Path(__file__).parent.parent / "data" / "examples"
    
    # URLs de prote√≠nas exemplo do PDB
    example_proteins = [
        {
            "name": "1abc.pdb",
            "url": "https://files.rcsb.org/download/1ABC.pdb",
            "description": "Prote√≠na exemplo pequena"
        },
        {
            "name": "2xyz.pdb", 
            "url": "https://files.rcsb.org/download/2XYZ.pdb",
            "description": "Prote√≠na exemplo m√©dia"
        }
    ]
    
    downloaded = []
    
    for protein in example_proteins:
        file_path = examples_dir / protein["name"]
        
        if file_path.exists():
            print(f"  ‚úÖ {protein['name']} j√° existe")
            continue
        
        try:
            print(f"  üì• Baixando {protein['name']}...")
            response = requests.get(protein["url"], timeout=30)
            response.raise_for_status()
            
            with open(file_path, 'w') as f:
                f.write(response.text)
            
            print(f"     ‚úÖ {protein['description']}")
            downloaded.append(protein["name"])
            
        except requests.RequestException as e:
            print(f"     ‚ùå Erro ao baixar {protein['name']}: {str(e)}")
        except Exception as e:
            print(f"     ‚ùå Erro inesperado: {str(e)}")
    
    if downloaded:
        print(f"\n‚úÖ {len(downloaded)} arquivo(s) de exemplo baixado(s)")
    
    return len(downloaded) > 0


def create_config_file():
    """Cria arquivo de configura√ß√£o personalizada"""
    print("\n‚öôÔ∏è  Criando arquivo de configura√ß√£o...")
    
    config_dir = Path(__file__).parent.parent / "configs"
    config_file = config_dir / "user_config.json"
    
    if config_file.exists():
        print("  ‚úÖ Configura√ß√£o j√° existe")
        return True
    
    # Configura√ß√£o padr√£o para usu√°rio
    user_config = {
        "parallel_processes": 4,
        "energy_cutoff": -5.0,
        "target_poses_per_probe": 10,
        "max_clusters": 15,
        "min_cluster_size": 5,
        "clustering_eps": 2.0,
        "output_formats": ["json", "csv", "html"],
        "enable_visualization": True,
        "verbose_output": False,
        "probe_molecules": {
            "water": {"smiles": "O", "charge": 0},
            "methanol": {"smiles": "CO", "charge": 0},
            "ethanol": {"smiles": "CCO", "charge": 0},
            "benzene": {"smiles": "c1ccccc1", "charge": 0},
            "acetate": {"smiles": "CC(=O)[O-]", "charge": -1}
        }
    }
    
    try:
        with open(config_file, 'w') as f:
            json.dump(user_config, f, indent=2)
        
        print(f"  ‚úÖ Configura√ß√£o criada: {config_file}")
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erro ao criar configura√ß√£o: {str(e)}")
        return False


def create_test_suite():
    """Cria suite b√°sica de testes"""
    print("\nüß™ Configurando suite de testes...")
    
    tests_dir = Path(__file__).parent.parent / "tests"
    
    # Teste unit√°rio b√°sico
    unit_test = '''#!/usr/bin/env python3
"""
Testes unit√°rios b√°sicos para FTMap Enhanced
"""

import unittest
import sys
from pathlib import Path

# Adicionar path dos m√≥dulos
sys.path.append(str(Path(__file__).parent.parent / "modules"))

from config import FTMapConfig


class TestConfig(unittest.TestCase):
    """Testes para configura√ß√£o"""
    
    def test_config_creation(self):
        """Testa cria√ß√£o da configura√ß√£o"""
        config = FTMapConfig()
        self.assertIsNotNone(config)
        self.assertGreater(len(config.PROBE_MOLECULES), 0)
    
    def test_config_values(self):
        """Testa valores padr√£o da configura√ß√£o"""
        config = FTMapConfig()
        self.assertGreater(config.PARALLEL_PROCESSES, 0)
        self.assertLess(config.ENERGY_CUTOFF, 0)


if __name__ == "__main__":
    unittest.main()
'''
    
    unit_test_file = tests_dir / "unit" / "test_config.py"
    
    try:
        with open(unit_test_file, 'w') as f:
            f.write(unit_test)
        
        print("  ‚úÖ Teste unit√°rio criado")
        
        # Tentar executar teste
        result = subprocess.run([
            sys.executable, str(unit_test_file)
        ], capture_output=True, text=True, cwd=tests_dir.parent)
        
        if result.returncode == 0:
            print("  ‚úÖ Teste executado com sucesso")
        else:
            print("  ‚ö†Ô∏è  Teste falhou - verifique configura√ß√£o")
        
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erro ao criar testes: {str(e)}")
        return False


def create_launcher_scripts():
    """Cria scripts de lan√ßamento convenientes"""
    print("\nüöÄ Criando scripts de lan√ßamento...")
    
    base_dir = Path(__file__).parent.parent
    
    # Script para Linux/Mac
    bash_script = f'''#!/bin/bash
# FTMap Enhanced Launcher

SCRIPT_DIR="$( cd "$( dirname "${{BASH_SOURCE[0]}}" )" &> /dev/null && pwd )"
cd "$SCRIPT_DIR"

python3 ftmap_cli.py "$@"
'''
    
    # Script para Windows
    batch_script = f'''@echo off
REM FTMap Enhanced Launcher

cd /d "%~dp0"
python ftmap_cli.py %*
'''
    
    try:
        # Criar script bash
        bash_file = base_dir / "ftmap.sh"
        with open(bash_file, 'w') as f:
            f.write(bash_script)
        bash_file.chmod(0o755)
        
        # Criar script batch  
        batch_file = base_dir / "ftmap.bat"
        with open(batch_file, 'w') as f:
            f.write(batch_script)
        
        print("  ‚úÖ Scripts de lan√ßamento criados")
        print(f"     üêß Linux/Mac: ./ftmap.sh")
        print(f"     ü™ü Windows: ftmap.bat")
        
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erro ao criar scripts: {str(e)}")
        return False


def run_verification_test():
    """Executa teste de verifica√ß√£o do sistema"""
    print("\nüîç Executando teste de verifica√ß√£o...")
    
    try:
        # Importar m√≥dulos principais
        sys.path.append(str(Path(__file__).parent / "modules"))
        
        print("  üß™ Testando imports...")
        from config import FTMapConfig
        from workflow_manager import FTMapWorkflowManager
        
        print("  ‚úÖ Imports OK")
        
        # Testar inicializa√ß√£o
        print("  üß™ Testando inicializa√ß√£o...")
        config = FTMapConfig()
        workflow = FTMapWorkflowManager(config=config, output_dir="/tmp/ftmap_test")
        
        print("  ‚úÖ Inicializa√ß√£o OK")
        
        # Verificar status
        status = workflow.get_workflow_status()
        print(f"  ‚úÖ Status: {status['output_directory']}")
        
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erro na verifica√ß√£o: {str(e)}")
        return False


def main():
    """Fun√ß√£o principal do setup"""
    print_header()
    
    # Verifica√ß√µes e instala√ß√µes
    checks = [
        ("Vers√£o do Python", check_python_version),
        ("Depend√™ncias Python", install_pip_dependencies),
        ("Ferramentas Externas", check_external_tools),
        ("Estrutura de Diret√≥rios", setup_directories),
        ("Arquivos de Exemplo", download_example_files),
        ("Arquivo de Configura√ß√£o", create_config_file),
        ("Suite de Testes", create_test_suite),
        ("Scripts de Lan√ßamento", create_launcher_scripts),
        ("Verifica√ß√£o Final", run_verification_test)
    ]
    
    results = []
    
    for name, check_func in checks:
        print(f"\n{'='*50}")
        print(f"üîß {name}")
        print(f"{'='*50}")
        
        try:
            success = check_func()
            results.append((name, success))
        except Exception as e:
            print(f"‚ùå Erro inesperado em {name}: {str(e)}")
            results.append((name, False))
    
    # Resumo final
    print(f"\n{'='*50}")
    print("üìä RESUMO DA INSTALA√á√ÉO")
    print(f"{'='*50}")
    
    successful = 0
    for name, success in results:
        status = "‚úÖ" if success else "‚ùå"
        print(f"{status} {name}")
        if success:
            successful += 1
    
    print(f"\nüìà {successful}/{len(results)} verifica√ß√µes bem-sucedidas")
    
    if successful == len(results):
        print("\nüéâ Setup conclu√≠do com sucesso!")
        print("\nüöÄ Para come√ßar:")
        print("   ./ftmap.sh example_protein.pdb")
        print("   ou")
        print("   python ftmap_cli.py example_protein.pdb")
    else:
        print("\n‚ö†Ô∏è  Setup conclu√≠do com problemas")
        print("üí° Revise os erros acima antes de usar o sistema")
    
    print(f"\nüìö Documenta√ß√£o e exemplos em:")
    print(f"   üìÅ {Path(__file__).parent.parent}")


if __name__ == "__main__":
    main()
